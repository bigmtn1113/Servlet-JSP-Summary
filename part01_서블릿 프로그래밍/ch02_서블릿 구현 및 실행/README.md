# 2. 서블릿 구현 및 실행
서블릿을 사용하기 전에는 웹서버에서 외부 프로그램을 호출하고 수행 결과를 웹 브라우저로 전송하는 `CGI(Common Gateway Interface)`라는 기술을 사용한다.
그러나 CGI 기술은 동시 접속자가 많아질수록 처리 효율이 떨어지는 단점이 있다.

그래서 서블릿이 등장하게 되었다.

## 2.1 웹 애플리케이션
### 2.1.1. 웹 애플리케이션 접근
http://70.12.220.93:8080/edu/index.jsp에 클라이언트가 URL로 접근을 하는 과정이다.

1. IP가 70.12.220.93인 `컴퓨터`를 찾아간다.
2. 8080 포트를 사용하고 있는 `서버`를 찾아간다.
3. edu라는 이름의 `웹 애플리케이션`을 찾아간다.
4. /index.jsp `파일`을 찾아간다.

<br/>

### 2.1.2. 웹 애플리케이션 위치
웹서버마다 시작될 때 자동으로 애플리케이션으로 인식하여 서비스를 올려주는 디렉터리가 있다.  
WAS 종류에 따라 다를 수 있는데 tomcat은 `webapps` 디렉터리에 애플리케이션들이 있다.  
webapps 디렉터리에 있는 하위 디렉터리 또는 디렉터리가 압축된 war 파일은 하나의 애플리케이션으로 인식한다.  
만약 webapps 디렉터리 안에 5개의 애플리케이션 디렉터리가 있으면 현재 tomcat 서버는 5개의 애플리케이션을 서비스하고 있는 것이다.

웹 애플리케이션의 루트 디렉터리는 `"WebContent"`이다. 이 디렉터리가 webapps의 하위 디렉터리에 해당한다.  
윈도우 탐색기에선 디렉터리 이름이 WebContent가 아니라 웹 프로젝트 이름으로 표시된다.  
어차피 이 디렉터리는 URL에서 `"/"`라는 기호로 접근하므로 디렉터리 이름이 무엇인지는 상관없다.

<br/>

### 2.1.3. 웹 애플리케이션 구조
웹 애플리케이션은 하나의 디렉터리이다.  
이 디렉터리 안에 서비스하려는 문서들을 만들어 놓으면 웹에서 서비스되는 것이다.

그런데 반드시 모든 웹 애플리케이션이 공통으로 가져야 하는 디렉터리와 파일이 있다.  
바로 `WEB-INF` 디렉터리이며, WEB-INF 디렉터리에는 `web.xml` 파일이 있어야 한다.

현재 웹 애플리케이션에서 서비스하려는 클래스 파일이 있다면 `WEB-INF/classes` 디렉터리 안에 있어야 한다.  
클래스 파일들이 jar로 압축되어 있다면 `WEB-INF/lib` 디렉터리 안에 있어야 한다.  
왜냐하면 WAS를 구성하는 애플리케이션 서버들이 자동으로 인식할 수 있기 때문이다.

<br/>

### 2.1.4. 환경설정 파일: web.xml
web.xml은 웹 애플리케이션 실행에 관해 정의하는 `환경설정` 파일이며, 웹 애플리케이션 서비스 시작 시 웹서버가 읽어서 사용하는 파일이다.  

<br/>

### 2.1.5. 서블릿 디렉터리
서블릿이 공식적으로 존재하는 디렉터리로서 모든 WAS의 구조가 같다.  
서블릿 프로그램 실행에 관련된 클래스 파일들은 `WEB-INf/classes` 디렉터리에 있어야만 `서블릿 컨테이너`가 인식하여 실행한다.  
이 디렉터리는 프로젝트 탐색 창에선 클래스 파일들을 직접 편집할 일이 없으므로 표시되지 않지만 윈도우 탐색기에선 표시된다.

<br/>

## 2.2. 서블릿 구현
웹 브라우저에서 클라이언트의 요청에 따라 서버가 실행할 수 있는 자바 프로그램은 서블릿뿐이다.  
이 말은 오직 서블릿만이 웹에서 동작하는 특별한 조건을 갖고 있다는 뜻이다.  
이러한 조건은 `서블릿 API`를 통해 제공하고 있으므로 서블릿을 구현할 때 해당 API만 상속하면 웹에서 동작하는 기본 조건을 갖출 수 있다.

### 2.2.1. 서블릿 API 문서
WAS에서 제공하는 서블릿 API를 제대로 활용하려면 해당 문서를 참고해야 한다.

<br/>

### 2.2.2. 서블릿 클래스 간의 관계
서블릿을 구현하려면 `HttpServlet` 클래스를 반드시 상속받아야 한다.  
HttpServlet에는 웹상에서 클라이언트 요청이 있을 때 해당 서블릿을 실행하는 모든 조건이 포함되어 있다.  
HttpServlet을 상속받지 않은 클래스는 서블릿이라 할 수 없고, 실행 요청이 와도 실행되지 않는다.

**서블릿 프로그램의 클래스 계층 구조**  
Servlet - GenericServlet - HttpServlet

- **Servlet 인터페이스**  
  init(), service(), destroy(), getServletConfig(), getServletInfo() 등 5개의 메소드를 선언하고 있다.  
  이는 서블릿 프로그램 실행의 `생명주기`와 연관된 메소드이다.
  
- **GenericServlet 클래스**  
  `Servlet` 인터페이스를 상속하여 서버단의 애플리케이션으로서 필요한 기능을 구현한 `추상 클래스`이다.  
  service() 메소드를 제외한 모든 메소드를 재정의하여 적절한 기능으로 구현하였다.
  
- **HttpServlet 클래스**  
  GenericServlet 클래스를 상속하여 service() 메소드를 재정의함으로써 `HTTP 프로토콜`에 알맞은 동작을 수행하도록 구현한 클래스이다.  
  service() 메소드에는 요청방식에 따라 doGet(), doPost() 등 메소드가 호출되도록 구현되어 있다.

<br/>

### 2.2.3. 서블릿 작성
HttpServlet은 서블릿이 웹상에서 `HTTP 프로토콜`을 이용해 서비스를 처리하기 위해 반드시 상속받아야 하는 클래스이다.  

```java
import javax.servlet.http.*;

public class FirstServlet extends HttpServlet { ... }
```

<br/>

### 2.2.4. 서블릿 실행 순서
서블릿의 실행 순서를 이해하려면 `IoC`라는 개념을 알아야 한다.

**IoC(Inversion of Control)**  
개발자가 아닌 제3자가 프로그램의 실행 흐름을 제어하는 것을 말한다.

**서블릿 실행 순서**  
client -(요청 정보)-> 웹서버 -> 서블릿 컨테이너 -> 최초요청 O -> 메모리 로딩 -> 객체 생성 -> init() -> service()  
client -(요청 정보)-> 웹서버 -> 서블릿 컨테이너 -> 최초요청 X -> service()

1. **클라이언트로부터 처리 요청받음**  
  웹서버는 클라이언트의 요청을 받아서 요청정보의 헤더 안에 있는 `URI를 분석`한다.  
  이때, 요청받은 페이지가 서블릿이면 서블릿 컨테이너에 처리를 넘긴다.  
  서블릿 컨테이너는 요청받은 서블릿을 `WEB-INF/classes`나 `WEB-INF/lib`에서 찾아서 실행 준비를 한다.
  
2. **최초의 요청 여부 판단**  
  서블릿 컨테이너는 현재 실행할 서블릿이 `최초요청`인지 판단한다.  
  실행할 서블릿 객체가 `메모리`에 없으면 최초요청이다.
  
3. **서블릿 객체 생성**  
  최초요청이면 해당 서블릿을 메모리에 `로딩`하고 객체를 생성한다.  
  이때 생성된 객체를 계속 사용한다.
  
4. **init() 메소드 실행**  
  서블릿 객체가 생성된 다음에 호출되는 메소드로서, 주로 서블릿 객체의 `초기화` 작업이 구현되어 있다.  
  최초요청 시에만 한 번 실행된다.
  
5. **service() 메소드 실행**  
  실제 서블릿에서 처리해야 하는 내용이 구현되어 있다.
  클라이언트 요청이 있을 때마다 실행된다.  

<br/>

### 2.2.5. 콜백 메소드와 서블릿 객체의 생명주기
**콜백 메소드(callback method)**  
어떤 객체에서 `어떤 상황(이벤트)`이 발생하면 컨테이너가 자동으로 호출하여 실행되는 메소드를 의미한다.  
이런 콜백 메소드들이 서블릿을 실행한다.

**서블릿의 콜백 메소드**  
- init(): 클라이언트로부터 최초로 서블릿 요청이 있을 때 한 번 실행되며 초기화 작업을 진행한다.  
- service(): 클라이언트로부터 요청이 있을 때마다 실행되며 실제 서블릿이 처리해야 하는 작업을 진행한다.  
- destroy(): 서블릿 객체가 메모리에서 삭제될 때 한 번 실행되며 자원 해제 작업을 진행한다.

**서블릿 객체의 생성**  
이전의 다른 `CGI` 프로그램들은 요청이 있을 때마다 독립적으로 처리되었지만, 서블릿은 한 번 생성한 객체를 `재사용`하는 것이라 처리속도, 메모리 부분에서 이전의 기술보다 `효율`적인 장점이 있다.

**서블릿 객체의 삭제**  
서블릿 객체가 삭제되는 시점은 웹서버에서 웹 애플리케이션 서비스가 중지되는 시점이다.  
이때 자원을 해제하는 destroy() 메소드가 호출되어 실행된다.

<br/>

## 2.3. 서블릿 실행
/WEB-INF는 웹서버가 사용하는 파일이 들어있는 중요한 디렉터리이다.  
따라서 외부에서 클라이언트가 곧바로 접근할 수 없도록 막아놓았다.  
그래서 URL로 곧바로 접근할 수 없는 것이다.

그렇다면 클라이언트가 어떻게 서블릿에 접근할 수 있을까?  
`web.xml`과 `어노테이션(annotation)`을 이용하여 서블릿 접근 경로를 지정하면 된다.

### 2.3.1. web.xml 설정을 통해 접근
1. **실행할 서블릿을 웹서버에 등록**  
  ```xml
  <servlet>
    <servlet-name></servlet-name>
    <servlet-class></servlet-class>
  </servlet>
  ```
  
  - `<servlet>` 태그는 HttpServlet을 상속받고 있는 클래스를 web.xml에 등록할 때 사용한다.  
  - `<servlet-name>` 태그는 등록하는 서블릿의 이름을 부여한다.  
  - `<servlet-class>` 태그는 등록하는 서블릿의 실제 클래스 이름을 지정한다. 웹서버가 서블릿을 찾아갈 때 사용하는 정보다.
    
2. **`<servlet>`으로 등록한 서블릿을 실행할 URI 지정**
  ```xml
  <servlet-mapping>
    <servlet-name></servlet-name>
    <url-pattern></url-pattern>
  </servlet-mapping>
  ```
  
  - `<servlet-mapping>` 태그는 `<servlet>` 태그로 등록한 서블릿을 실행 요청할 때 사용할 URL을 지정하기 위해 사용한다.  
  - `<servlet-name>` 태그는 실행할 서블릿 이름을 지정한다. `<servlet>` 태그에서 등록한 서블릿 이름으로 지정해야 한다.  
  - `<url-pattern>` 태그는 서블릿을 실행할 때 사용할 URL을 지정한다.
    이때 'http://서버주소:포트번호/웹 애플리케이션이름'까지는 생략하고 그 다음부터 지정한다.
    현재 웹 애플리케이션을 찾아오기까지의 정보는 고정되어 있으므로 생략가능한 것이다.

<br/>

### 2.3.2. @WebServlet을 통해 접근
어노테이션은 자바 주석문처럼 소스 안에 `@` 기호와 함께 사용된다.  
주석문처럼 컴파일러에 정보를 알려주는 기능, 또는 자바프로그램 실행에 관한 내용을 설정하는 용도로 사용된다.  

```java
@WebServlet("/hello2")
public class FirstServlet extends HttpServlet { ... }
```

`web.xml로 설정하는 방식`은 여러 개의 서블릿을 태그로 등록하기 때무에 전체적인 관리가 쉽다.  
또한, URL 값이 변경되어야 할 때는 소스를 수정하지 않고서도 web.xml에서 쉽게 변경할 수 있다.

`@WebServlet 설정 방식`은 설정파일 없이 자바 소스에서 쉽게 URL 패턴을 지정할 수 있다.  
그러나 하나의 자바 소스에 하나의 서블릿 매핑만 가능하므로 전체적인 관리가 어려워 유지보수성이 떨어진다.  
또한, URL 패턴값이 달라지면 소스를 수정해야 해서 다시 컴파일해야 한다.

<br/>

### 2.3.3. 요청방식에 따른 실행
HttpServlet이 갖고 있는 두 가지 형태의 service() 메소드를 살펴보자.

```java
protected void service(HttpServletRequest req, HttpServletResponse resp)
public void service(ServletRequest req, ServletResponse resp)
```

`첫 번째 service() 메소드`는 클라이언트의 실행요청에 따라 서로 다른 메소드를 호출하도록 구현되어 있다.  
`두 번째 service() 메소드`는 서블릿 요청이 있을 때마다 실행되는 메소드이며 단순히 첫 번째 service()를 호출만 하는 역할을 수행한다.

첫 번째 service() 메소드가 실행될 때 클라이언트가 `GET 방식`으로 요청했다면 `doGet()`을, `POST 방식`으로 요청했다면 `doPost()` 메소드를 호출한다.
만약 요청방식에 따라 다르게 동작하게 하려면 service()를 재정의 하지 말고 doGet() 또는 doPost() 메소드 등을 재정의하면 된다.

**service() 메소드를 재정의하지 않은 상태에서 GET 방식 요청이 들어왔을 경우 메소드 실행 순서**  
1. **init(ServletConfig)** - GenericServlet
2. **service(ServletRequest, ServletResponse)** - HttpServlet
3. **service(HttpServletRequest, HttpServletResponse)** - HttpServlet
4. **doGet(HttpServletRequest, HttpServletResponse)** - XXXServlet
