# 15. 웹 애플리케이션 디자인 패턴
`디자인 패턴`은 프로그램을 개발할 때 사용하는 일종의 `뼈대(프레임)` 또는 `틀`이라고 생각하면 된다.  
디자인 패턴에는 구현 시 페이지를 어떻게 나눠야 하는지, 각 페이지의 기능은 무엇인지,  
페이지와 페이지 간의 관계까지 정의되어 있어서 개발자는 고민없이 정해진 디자인 패턴대로 구현하면 된다.

<br/>

## 15.1. MVC 디자인 패턴
### 15.1.1. MVC 디자인 패턴 기본 예제
- **Member.java**: JSP Bean 객체
- **MemberService.java**: 회원 서비스 처리 객체
- **MemberDAO.java**: 회원 데이터베이스 처리 객체
- **memberInput.jsp**: 회원가입 입력 화면 페이지
- **memberOutput.jsp**: 회원가입 처리 결과 페이지
- **memberProc.jsp**: 회원가입 처리 페이지
- **memberTable.jsp**: member 테이블 생성 페이지

**실행 흐름**  
memberTable.jsp를 실행시켜 member 테이블을 데이터베이스에 생성한 다음의 흐름이다.

memberInput.jsp -> memberProc.jsp -> MemberService.java -> MemberDAO.java -> DB  
-> MemberDAO.java -> MemberService.java -> memberProc.java -> memberOutput.jsp

<br/>

### 15.1.2. MVC
MVC 패턴은 애플리케이션을 세 가지 영역, 즉 모델(Model), 뷰(View), 컨트롤러(Controller)로 구분하여 작업을 분리함으로써,  
서로 간의 `결합도`를 최소화하고 `유지보수성`도 높이며, 개발자들이 각각 맡은 영역에만 집중할 수 있게 하여 개발의 `효율성`을  
극대화할 수 있는 장점이 있다.

`뷰`는 HTML, CSS, JSP를 사용하여 구현하고, `컨트롤러`는 JSP, 서블릿을 사용하여 구현하며, `모델`은 자바로 구현한다.

<br/>

#### [1] 뷰(View)
클라이언트와 서버 간의 `인터페이스 역할`을 하는 영역으로서 클라이언트로부터 요청받거나 처리된 결과를 보여주는 기능을 한다.

<br/>

#### [2] 컨트롤러(Controller)
뷰에서 클라이언트가 서비스를 요청했을 때 실행되는 페이지이다.  
서비스를 처리하는 메소드를 호출함으로써 클라이언트 요청과 서비스 처리 객체를 연결해주는 `중계 역할`을 하면서  
서비스 처리 흐름을 제어한다.

1. 뷰에서 들어온 요청을 받는다.
2. 클라이언트가 전달한 파라미터를 추출한다.
3. 파라미터의 유효성을 검사한다.
4. 서비스 객체의 메소드를 호출하며 파라미터를 서비스 객체로 전달한다.
5. 출력 뷰 페이지로 이동한다.

<br/>

#### [3] 모델(Model)
MVC 패턴에서 모델은 두 가지로 구분한다.  
하나는 서비스 처리를 담당하는 `Service 객체`이며, 다른 하나는 데이터베이스 처리를 담당하는 `DAO 객체`이다.

**Service 객체**  
서비스 처리를 하기 위한 내용으로만 구현된 객체를 `Service` 또는 `Business` 객체라고 한다.  
모델의 하나이며 일반 자바로 작성한다.

평범한 일반 자바를 `POJO(Plain Old Java Object)`라고 부르기 때문에 Model을 개발할 때 POJO로 개발한다고 한다.

**DAO 객체**  
데이터베이스에 관련된 기능들만 구현한다.  
데이터베이스 처리에 관한 기능만으로 구성되는 객체를 `DAO(Data Access Object)` 객체라고 하며 MVC 패턴의 모델 중 하나이다.

DAO 객체 역시 POJO로 작성한다.

<br/>

**※ MVC 디자인 패턴의 두 가지 모델**  
MVC 디자인 패턴에는 `Model1`과 `Model2` 라는 두 가지 모델이 있다.  
컨트롤러를 `JSP`로 작성하면 Model1, `서블릿`으로 작성하면 Model2이다.

`Model1`은 컨트롤러와 뷰의 구분없이 간단하고 빠르게 개발할 수 있는 장점이 있지만,  
구현 작업이 복잡할 때는 역할이 구분되지 않아서 유지보수가 어려워진다는 단점이 있다.

`Model2`는 역할의 구분이 확실하기 때문에 설계가 Model1보다 어렵지만, 유지보수가 수월해지는 장점이 있다.

<br/>

### 15.1.3. 3계층 아키텍처
웹 애플리케이션을 개발할 때 디자인 패턴은 `MVC 패턴`을 사용하며, 구조적인 측면에서 `3계층 아키텍처(3-Tier Architecture)`를 사용한다.

- **프레젠테이션 계층(Presentation tier)**: 뷰와 컨트롤러가 있는 영역
- **비즈니스 계층(Business tier)**: 비즈니스 로직이 구현된 영역
- **영속 계층(Persistent tier)**: 데이터베이스에 대한 처리를 하는 영역

3계층 아키텍처의 장점은 각 영역이 독립적으로 이루어져서 하나의 영역에서 변경이 일어났을 때 다른 영역에 변경된 내용이  
영향을 미치지 않아, 서로 간의 `의존성은 최소화`하고 `독립성은 최대화`할 수 있다는 것이다.

<br/>

#### [1] 프레젠테이션 계층
최상위에 위치하는 영역으로서 클라이언트와 애플리케이션 간에 상호작용할 수 있게 하는 `인터페이스 역할`을 담당한다.  
클라이언트로부터 서비스를 요청받아서 비즈니스 계층의 메소드를 호출해주거나, 클라이언트가 보낸 데이터를 비즈니스 계층으로
전달하는 기능만 구현한다. 또한, 비즈니스 계층의 작업이 끝난 다음 처리 결과 뷰 페이지로 이동하는 기능도 구현한다.

`프런트엔드(front-end)`라고도 불리며 HTML, CSS, JavaScript, JSP, Servlet, Image 등이 사용된다.

<br/>

#### [2] 비즈니스 계층
클라이언트가 요청한 `서비스를 처리`하는 비즈니스 로직이 구현되는 영역이다.  
클라이언트와는 직접적으로 연결되지 않으며, 단지 프레젠테이션 계층과 연결되어 실행되는 영역이다.  
전적으로 서비스 처리에 관한 기능만 구현한다.

`미들웨어(middleware)` 또는 `백엔드(back-end)`라고도 부른다.

<br/>

#### [3] 영속 계층
여러 가지 종류의 데이터베이스 서버나 파일 시스템에 접근하여 데이터를 생성, 관리하는 기능을 담당하는 영역이다.  
서비스를 처리하면서 영구적으로 저장된 데이터를 추출, 수정, 삭제 또는 생성하는 작업을 처리한다.

`백엔드(back-end)`라고도 부른다.

<br/>

## 15.2. 프레임워크
프레임워크(Framework)는 `반제품`이다.  
완제품처럼 완벽하게 완성되어 바로 사용할 수 있는 것이 아니고, 미완성 상태를 의미한다.

프레임워크를 사용하면 어느 정도는 완성되어 있어서 개발자가 할 일이 줄어든다.  
즉, 개발 기간이 단축되고 개발 비용이 낮아진다는 뜻이다.

3계층 아키텍처 구조는 구성요소 간의 관계를 만드는 책임이 전적으로 개발자에게 있지만,  
프레임워크는 이미 그 틀이 객체지향적으로 구현되어 있어서 별도로 노력하지 않아도 된다.

<br/>

### 15.2.1. 프레임워크 정의와 장단점
#### [1] 프레임워크의 장점
**개발 기간 단축**  
대부분 프레임워크에서는 애플리케이션 개발에 필요한 기능들을 미리 구현하여 `라이브러리 파일`로 제공한다.  
따라서 개발자가 필요한 기능을 구현할 필요 없이 프레임워크에서 제공하는 라이브러리를 가져다 사용하면 되므로  
빠르고 간편하게 개발할 수 있다.

**성능 향상**  
대부분 프레임워크는 검증된 효율적인 아키텍처와 설계를 사용하고 있어서 개발자가 의도하지 않아도 프레임워크에서 제공하는 아키텍처를 따르게 된다.
그러므로 개발자의 낮은 개발 능력 또한 프레임워크에서 내부적으로 사용하는 고급 수준의 코딩 패턴을 그대로 사용하면 자연적으로 해결할 수 있다.

**유지보수성 향상**  
프레임워크로 개발된 애플리케이션은 일정한 아키텍처를 사용하므로 개발 및 유지보수 담당자가 변경되더라도  
업무파악을 빠르게 할 수 있다.

<br/>

#### [2] 프레임워크의 단점
**프레임워크 학습 필요**  
프레임워크를 사용하려면 사용 전에 프레임워크에 익숙해지기 위해 학습해야 한다.  

**프레임워크 선택 어려움**  
잘못된 프레임워크를 선택하여 개발하면 개발 및 운영, 유지보수에 많은 어려움을 초래할 수도 있다.  
따라서 개발하는 애플리케이션에 적합하고 검증된 프레임워크를 선택해야 한다.

**유연성 부족**  
프레임워크가 아무리 훌륭하더라도 개발하면서 발생할 수 있는 모든 상황을 처리할 순 없다.  
따라서 프레임워크에서 지원하지 않는 기능은 프레임워크를 커스터마이징해서 처리해야 한다.  
이 작업이 일반적으로 쉽지가 않다. 즉, 유연성이 부족하다.

<br/>

### 15.2.2. 프레임워크 종류
프레임워크는 `3계층 아키텍처` 각 영역별로 존재한다.  
대표적인 오픈소스 프레임워크들을 간단하게 살펴보자.

<br/>

#### [1] 프레젠테이션 프레임워크
**스프럿츠(Struts)**  
아파치 스트럿츠는 2000년대 해외뿐만 아니라 국내에서도 개발자들이 가장 많이 사용하던 프레젠테이션 프레임워크이다.

**스프링(Spring)**  
통합 프레임워크로서 여러 개의 모듈이 존재하며, 그중 하나가 프레젠테이션 계층을 개발하는 `Spring MVC`이다.  
현재 많은 업체에서 스프링 프레임워크를 직접 이용하거나 스프링을 기반으로 하는 자체 프레임워크로 시스템을 구축하고 있다.

<br/>

#### [2] 비즈니스 프레임워크
프레임워크에서 정해진 기능을 제공하는 것이 아니고, 비즈니스 객체를 효율적인 디자인 패턴을 사용해서 구현할 수 있게 돕는 프레임워크이다.
`Spring IoC`, `AOP`도 비즈니스 객체를 구현 및 작업할 수 있게 돕는 프레임워크이다.

<br/>

#### [3] 영속 프레임워크
**myBatis**  
아파치 프로젝트에서 iBatis 이름으로 출발했으나 2010년 myBatis로 이름을 변경되었다.  
`XML 파일`에 데이터베이스 처리에 관한 `SQL` 문을 설정한 후 `자바` 소스에서 간단하게 연결하여 데이터를 처리할 수 있다.  
사용방법이 간단해서 국내 개발자들이 많이 사용하는 영속 프레임워크이다.

**Hibernate**  
`ORM(Object-Relational Mapping)` 프레임워크라고도 부르는 영속 프레임워크로서 자바 객체와 데이터베이스의 데이터를
객체 지향으로 매핑하여 데이터를 처리하므로 엔터프라이즈 개발 환경에 적합하다.
그러나 객체 모델링에 관한 충분한 경험이 없다면 사용하기 어렵다는 특징이 있다.

<br/>

## 15.3. 프런트 컨트롤러 디자인 패턴
하나의 웹 애플리케이션에는 많은 뷰와 많은 컨트롤러가 존재해서 각각의 뷰와 컨트롤러가 연결되어 독립적으로 실행되면,
서버 입장에서는 현재 웹 애플리케이션 실행에 대하여 일괄적으로 처리하기가 어렵다.
이런 구조에서는 뷰에서 들어오는 요청에 대하여 각각의 컨트롤러에서만 처리할 수 있으므로 수많은 뷰의 요청을 통제할 수 없다.

이때 대표 컨트롤러(Front Controller)를 두고 뷰에서 들어오는 모든 요청을 담당하게 하면 웹 애플리케이션을 실행하는  
모든 요청을 일괄적으로 처리할 수 있다. 이러한 구조를 `프런트 컨트롤러 디자인 패턴`이라고 한다.

<br/>

### 15.3.1. 프런트 컨트롤러 설정
프런트 컨트롤러는 웹 애플리케이션의 `모든 요청에 우선으로 실행`되어야 한다.

#### [1] URL 패턴 지정
웹 애플리케이션 개발 전에 클라이언트의 요청 URL에 `요청 패턴`을 지정한다.  
일반적으로 요청되는 URL의 끝에 특정 단어를 붙이는데 `~.do`나 `~.action`과 같은 단어를 지정한다.

```HTML
<a href="memberInsert.do">회원가입</a>
<a href="memberSearch.do">회원 정보 조회</a>
<a href="memberUpdate.do">회원 정보 수정</a>
<a href="memberDelete.do">회원 탈퇴</a>
```

<br/>

#### [2] 프런트 컨트롤러 등록
모든 요청 URL 끝에 공통으로 .do가 들어오도록 구현했다면, 이 요청에 대응하여 실행할 `프런트 컨트롤러 클래스`를 생성한 후에
`web.xml`에 등록하면 프런트 컨트롤러로서 동작한다.

```xml
<servlet>
  <servlet-name>front</servlet-name>
  <servlet-class>~~.FrontController</servlet-class>
</servlet>

<servlet-mapping>
  <servlet-name>front</servlet-name>
  <url-pattern>*.do</url-pattern>
</servlet-mapping>
```

클라이언트로부터 전달되는 URL에 어떤 값이 들어와도, URL 끝부분이 .do로 끝나면 front 서블릿을 실행하라는 의미이다.

<br/>

### 15.3.2. 서브 컨트롤러 연결
프런트 컨트롤러에서 일괄적으로 처리할 기능을 구현하고, 처리가 완료된 후에는 반드시 실제 요청한 서비스를 처리하는 컨트롤러가 실행되게 해야 한다.
프런트 컨트롤러는 어떤 요청에 대하여 어떤 서브 컨트롤러가 실행되어야 하는지에 대한 정보를 알고 있어야 한다.
이러한 정보는 주로 `map` 객체에 저장하며 저장된 정보에서 서브 컨트롤러를 찾아서 실행한다.

key | value
---|---
memberInsert.do | MemberInsert
memberSearch.do | MemberSearch
memberUpdate.do | MemberUpdate
memberDelete.do | MemberDelete
